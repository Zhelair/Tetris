<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>Protest Tetris</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: Arial, sans-serif;
      color: #fff;
      background:
        linear-gradient(rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.85)),
        url("sofia.png") center/cover no-repeat fixed;
      background-color: #050813;
    }

    .wrapper {
      display: flex;
      flex-direction: row;
      gap: 12px;
      align-items: flex-start;
      padding: 8px 10px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
      max-width: 100%;
      box-sizing: border-box;
    }

    #game {
      background: transparent;
      border: 2px solid #555;
      display: block;
    }

    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 165px;
    }

    button {
      padding: 5px 7px;
      font-size: 12px;
      border: none;
      cursor: pointer;
      background: #ffcc00;
      color: #000;
      border-radius: 8px;
    }

    button:hover {
      filter: brightness(1.1);
    }

    /* ГОЛЕМИ, удобни бутони за телефон */
    .touch-controls {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
      margin-top: 10px;
      width: 100%;
    }

    .touch-controls button {
      padding: 10px;
      font-size: 18px;
      min-height: 52px;
      border-radius: 10px;
      font-weight: bold;
    }

    /* По-малки служебни бутони */
    .system-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 10px;
      width: 100%;
      justify-content: space-between;
    }

    .system-controls button {
      flex: 1 1 30%;
      padding: 6px;
      font-size: 11px;
      min-height: 34px;
      border-radius: 8px;
      font-weight: normal;
    }

    .label {
      font-weight: bold;
      font-size: 13px;
    }

    .value {
      font-size: 15px;
      margin-top: 1px;
    }

    @media (max-width: 700px) {
      body {
        justify-content: center;
        align-items: flex-start;
        padding-top: 6px;
      }

      .wrapper {
        flex-direction: column;
        align-items: center;
        width: 100%;
        max-width: 380px;
      }

      .side-panel {
        width: 100%;
        align-items: stretch;
      }

      #game {
        margin-bottom: 6px;
      }
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <canvas id="game"></canvas>

    <div class="side-panel">
      <div>
        <div class="label">Изчистена корупция:</div>
        <div id="score" class="value">0</div>
      </div>

      <div>
        <div class="label">Ниво:</div>
        <div id="level" class="value">1</div>
      </div>

      <div>
        <div class="label">Гняв:</div>
        <div id="rage" class="value">0 / 5</div>
      </div>

      <div style="font-size:10px;opacity:0.9;max-width:220px;">
        ← → местене, ↓ падане, ↑ завъртане, Space = твърдо пускане
      </div>

      <!-- ОСНОВНИ КОНТРОЛИ ЗА ДОКОСВАНЕ -->
      <div class="touch-controls">
        <button data-action="left">◀</button>
        <button data-action="down">⬇</button>
        <button data-action="right">▶</button>
        <button data-action="rotate">⟳</button>
        <button data-action="drop">⤓</button>
      </div>

      <!-- СИСТЕМНИ БУТОНИ -->
      <div class="system-controls">
        <button id="restart">Рестарт</button>
        <button id="pause">Пауза</button>
        <button id="toggleMusic">Пусни музика</button>
      </div>
    </div>
  </div>

  <audio id="bgm" src="music.mp3" loop></audio>
  <audio id="chant" src="chant.mp3"></audio>

  <script>
    // ===== CONFIG =====
    const COLS = 10;
    const ROWS = 20;
    const BLOCK = 22;
    const BASE_SPEED = 500;

    const WIDTH = COLS * BLOCK;
    const HEIGHT = ROWS * BLOCK;

    const boikoImages = [];
    ["boiko.png", "boiko_1.png", "boiko_2.png"].forEach(src => {
      const img = new Image();
      img.src = src;
      boikoImages.push(img);
    });

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const dpr = window.devicePixelRatio || 1;
    canvas.width = WIDTH * dpr;
    canvas.height = HEIGHT * dpr;
    canvas.style.width = WIDTH + "px";
    canvas.style.height = HEIGHT + "px";
    ctx.scale(dpr, dpr);

    const scoreEl = document.getElementById("score");
    const levelEl = document.getElementById("level");
    const rageEl  = document.getElementById("rage");
    const bgm = document.getElementById("bgm");
    const chant = document.getElementById("chant");
    const toggleMusicBtn = document.getElementById("toggleMusic");
    const restartBtn = document.getElementById("restart");
    const pauseBtn = document.getElementById("pause");
    const touchButtons = document.querySelectorAll(".touch-controls button");

    let musicPlaying = false;
    let board;
    let currentPiece;
    let gameOver;
    let score;
    let lastTick;
    let popups = [];
    let particles = [];
    let paused = false;
    let level = 1;
    let linesClearedTotal = 0;
    let fallSpeed = BASE_SPEED;
    let animationTime = 0;

    // Тълпа
    let crowdActive = false;
    let crowdTimer = 0;

    // TV "Всичко е наред"
    let spinActive = false;
    let spinNextTime = null;
    let spinEndTime = 0;

    // Гняв / Генерална стачка
    const RAGE_MAX = 5;
    let rage = 0;

    // Разклащане на екрана
    let shakeTimer = 0;

    // Проверка от ЕС
    let inspectionActive = false;
    let inspectionTimer = 0;
    let inspectionStep = 0;  // за ~на всеки 1.5 нива

    const SHAPES = [
      {cells:[[0,0],[-1,0],[1,0],[2,0]]},
      {cells:[[0,0],[0,1],[1,0],[1,1]]},
      {cells:[[0,0],[-1,0],[1,0],[0,1]]},
      {cells:[[0,0],[0,1],[0,2],[1,2]]},
      {cells:[[0,0],[0,1],[0,2],[-1,2]]},
      {cells:[[0,0],[1,0],[0,1],[-1,1]]},
      {cells:[[0,0],[-1,0],[0,1],[1,1]]}
    ];

    function emptyBoard() {
      return Array.from({length: ROWS}, () => Array(COLS).fill(null));
    }

    function rotate([x,y]) { return [y,-x]; }
    function rotateShape(cells) { return cells.map(rotate); }

    // Прасешка бомба – понякога едно блокче
    function spawnPiece() {
      const isPigBomb = Math.random() < 0.08;
      if (isPigBomb) {
        const imgIndex = Math.floor(Math.random() * boikoImages.length);
        return {
          x: Math.floor(COLS/2),
          y: 0,
          cells: [[0,0]],
          imgIndex,
          type: "pigBomb"
        };
      }

      const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
      const imgIndex = Math.floor(Math.random() * boikoImages.length);
      return {
        x: Math.floor(COLS/2),
        y: 0,
        cells: shape.cells.map(c=>[...c]),
        imgIndex,
        type: "normal"
      };
    }

    function valid(piece, dx=0, dy=0, newCells=null) {
      const cells = newCells || piece.cells;
      for (const [cx,cy] of cells) {
        const x = piece.x + cx + dx;
        const y = piece.y + cy + dy;
        if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
        if (board[y][x]) return false;
      }
      return true;
    }

    function merge(piece) {
      for (const [cx,cy] of piece.cells) {
        board[piece.y+cy][piece.x+cx] = { imgIndex: piece.imgIndex };
      }
    }

    function addPopup(text,row,center=false) {
      popups.push({ x:1.5, y:row, text, life:120, center });
    }

    function addParticlesForRow(row) {
      const y = row * BLOCK + BLOCK/2;
      for (let i=0; i<40; i++) {
        const x = Math.random() * WIDTH;
        const ang = Math.random()*Math.PI*2;
        const sp = 1 + Math.random()*2;
        particles.push({
          x,y,
          vx: Math.cos(ang)*sp,
          vy: Math.sin(ang)*sp - 1,
          life: 40 + Math.random()*20,
          mega: false
        });
      }
    }

    // Тълпа – чисти още един ред
    function triggerCrowdPower() {
      const rowsWithBlocks = [];
      for (let r=0; r<ROWS; r++) {
        if (board[r].some(cell => cell !== null)) {
          rowsWithBlocks.push(r);
        }
      }
      if (rowsWithBlocks.length === 0) return;

      const r = rowsWithBlocks[Math.floor(Math.random() * rowsWithBlocks.length)];
      board.splice(r, 1);
      board.unshift(new Array(COLS).fill(null));

      score += 50;
      scoreEl.textContent = score;

      addPopup("Сила на тълпата!", r, true);
      addParticlesForRow(r);

      crowdActive = true;
      crowdTimer = 120;
    }

    function addMegaExplosion() {
      for (let i=0; i<250; i++) {
        const x = Math.random() * WIDTH;
        const y = Math.random() * HEIGHT;
        const ang = Math.random()*Math.PI*2;
        const sp = 2 + Math.random()*3;
        particles.push({
          x,y,
          vx: Math.cos(ang)*sp,
          vy: Math.sin(ang)*sp - 1.5,
          life: 100 + Math.random()*40,
          mega: true
        });
      }
      popups.push({
        x: 1.5,
        y: 0.5,
        text: "МЕГА БУМ!",
        life: 140,
        center: true
      });
    }

    // Прасешки бонус – при 3+ реда
    function triggerPigBonus() {
      const rowsWithBlocks = [];
      for (let r=0; r<ROWS; r++) {
        if (board[r].some(c => c !== null)) {
          rowsWithBlocks.push(r);
        }
      }
      let extraCleared = 0;
      while (rowsWithBlocks.length > 0 && extraCleared < 2) {
        const idx = Math.floor(Math.random() * rowsWithBlocks.length);
        const r = rowsWithBlocks.splice(idx,1)[0];
        board.splice(r,1);
        board.unshift(new Array(COLS).fill(null));
        extraCleared++;
      }
      if (extraCleared > 0) {
        score += extraCleared * 80;
        scoreEl.textContent = score;
        addPopup("Прасешки бонус!", 1, true);
        shakeTimer = Math.max(shakeTimer, 12);
      }
    }

    // Прасешка бомба – кръстосано чистене
    function triggerPigBombExplosion(cx, cy) {
      const positions = [
        [cx, cy],
        [cx-1, cy],
        [cx+1, cy],
        [cx, cy-1],
        [cx, cy+1]
      ];
      positions.forEach(([x,y]) => {
        if (x>=0 && x<COLS && y>=0 && y<ROWS) {
          if (board[y][x]) board[y][x] = null;
        }
      });
      popups.push({
        x: 1.5,
        y: 0.5,
        text: "Прасешка бомба!",
        life: 120,
        center: true
      });
      shakeTimer = Math.max(shakeTimer, 16);
      for (let i=0; i<100; i++) {
        const ang = Math.random()*Math.PI*2;
        const sp = 1 + Math.random()*2.5;
        particles.push({
          x: cx*BLOCK + BLOCK/2,
          y: cy*BLOCK + BLOCK/2,
          vx: Math.cos(ang)*sp,
          vy: Math.sin(ang)*sp - 1,
          life: 80 + Math.random()*30,
          mega: false
        });
      }
    }

    function updateFallSpeed() {
      const normal = Math.max(150, BASE_SPEED - (level-1)*50);
      fallSpeed = spinActive ? normal * 2 : normal;
    }

    // Генерална стачка – чисти дъното
    function triggerGeneralStrike() {
      let toClear = 3;
      for (let r=ROWS-1; r>=0 && toClear>0; r--) {
        if (board[r].some(c => c !== null)) {
          board.splice(r,1);
          board.unshift(new Array(COLS).fill(null));
          toClear--;
        }
      }
      score += 150;
      scoreEl.textContent = score;
      popups.push({
        x: 1.5,
        y: 2,
        text: "Генерална стачка!",
        life: 140,
        center: true
      });
      addMegaExplosion();
      shakeTimer = Math.max(shakeTimer, 25);
    }

    // Проверка от ЕС
    function startEUInspection() {
      inspectionActive = true;
      inspectionTimer = 600;
      popups.push({
        x: 1.5,
        y: 0.5,
        text: "Проверка от ЕС",
        life: 140,
        center: true
      });
    }

    // Ниво на всеки 3 реда
    function levelUpIfNeeded() {
      const LINES_PER_LEVEL = 3;

      const newLevel = Math.floor(linesClearedTotal / LINES_PER_LEVEL) + 1;
      if (newLevel !== level) {
        level = newLevel;
        levelEl.textContent = level;

        score += 200;
        scoreEl.textContent = score;
        triggerCrowdPower();

        // Проверка от ЕС ~на всеки 1.5 нива, след ниво 2
        if (level >= 2) {
          inspectionStep += 1;
          if (inspectionStep >= 1.5) {
            startEUInspection();
            inspectionStep -= 1.5;
          }
        }

        updateFallSpeed();
        popups.push({
          x: 2,
          y: 1,
          text: "НИВО " + level,
          life: 140,
          center: true
        });
      }
    }

    function clearLines() {
      let clearedNow = 0;
      for (let r=ROWS-1; r>=0; r--) {
        if (board[r].every(c=>c!==null)) {
          board.splice(r,1);
          board.unshift(new Array(COLS).fill(null));
          score += 100;
          scoreEl.textContent = score;
          linesClearedTotal++;
          clearedNow++;

          addPopup("Корупция -1", r, true);
          addParticlesForRow(r);

          if (linesClearedTotal % 5 === 0) {
            addMegaExplosion();
          }

          r++;
        }
      }

      if (clearedNow > 0) {
        rage += clearedNow;
        if (rage > RAGE_MAX) rage = RAGE_MAX;
        rageEl.textContent = rage + " / " + RAGE_MAX;
      }

      if (clearedNow >= 3) {
        triggerPigBonus();
      }

      if (rage >= RAGE_MAX) {
        triggerGeneralStrike();
        rage = 0;
        rageEl.textContent = "0 / " + RAGE_MAX;
      }

      if (clearedNow >= 1) {
        if (Math.random() < 0.7) {
          triggerCrowdPower();
        }
      }

      if (clearedNow >= 2 && chant) {
        try {
          chant.currentTime = 0;
          chant.play();
        } catch(e){}
      }
      if (clearedNow > 0) {
        levelUpIfNeeded();
      }
    }

    function drawFlagBackground() {
      const h = HEIGHT/3;
      ctx.fillStyle="#ffffff"; ctx.fillRect(0,0,WIDTH,h);
      ctx.fillStyle="#00966E"; ctx.fillRect(0,h,WIDTH,h);
      ctx.fillStyle="#d62612"; ctx.fillRect(0,2*h,WIDTH,h);
    }

    function drawStaticCell(x,y,cell) {
      const px=x*BLOCK, py=y*BLOCK;
      const img=boikoImages[cell.imgIndex];
      ctx.save();
      if (img && img.complete && img.naturalWidth>0) {
        ctx.drawImage(img,px,py,BLOCK,BLOCK);
      }
      if (cell.bribed) { /* вече не ползваме bribed, но ако има стари данни – игнорираме */ }
      ctx.strokeStyle="rgba(0,0,0,0.7)";
      ctx.lineWidth=1;
      ctx.strokeRect(px+0.5, py+0.5, BLOCK-1, BLOCK-1);
      ctx.restore();
    }

    function drawRotatingCell(x,y,imgIndex) {
      const px=x*BLOCK, py=y*BLOCK;
      const img=boikoImages[imgIndex];
      const t = animationTime || 0;
      const angle = Math.sin(t/350 + (x+y)) * 0.18;

      ctx.save();
      ctx.translate(px + BLOCK/2, py + BLOCK/2);
      ctx.rotate(angle);

      if (img && img.complete && img.naturalWidth>0) {
        ctx.drawImage(img, -BLOCK/2, -BLOCK/2, BLOCK, BLOCK);
      } else {
        ctx.fillStyle="#ffffff";
        ctx.fillRect(-BLOCK/2, -BLOCK/2, BLOCK-1, BLOCK-1);
      }

      ctx.strokeStyle="rgba(0,0,0,0.7)";
      ctx.lineWidth=1;
      ctx.strokeRect(-BLOCK/2+0.5, -BLOCK/2+0.5, BLOCK-1, BLOCK-1);

      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0,0,WIDTH,HEIGHT);

      ctx.save();
      if (shakeTimer > 0) {
        const dx = (Math.random() - 0.5) * 4;
        const dy = (Math.random() - 0.5) * 4;
        ctx.translate(dx, dy);
        shakeTimer--;
      }

      drawFlagBackground();

      for (let r=0;r<ROWS;r++)
        for (let c=0;c<COLS;c++)
          if (board[r][c]) drawStaticCell(c,r,board[r][c]);

      if (!gameOver && currentPiece) {
        for (const [cx,cy] of currentPiece.cells) {
          drawRotatingCell(currentPiece.x+cx,currentPiece.y+cy,currentPiece.imgIndex);
        }
      }

      // Попъпи
      popups.forEach(p=>{
        ctx.save();
        ctx.font="13px Arial"; 
        ctx.lineWidth=3;

        let x = p.center ? WIDTH/2 : p.x*BLOCK;
        let y = p.y*BLOCK + BLOCK/2;

        ctx.textAlign = p.center ? "center" : "left";

        ctx.strokeStyle="#000";
        ctx.strokeText(p.text,x,y);
        ctx.fillStyle="#ffea00";
        ctx.fillText(p.text,x,y);

        p.y -= 0.02; 
        p.life--;
        ctx.restore();
      });
      popups=popups.filter(p=>p.life>0);

      // Частици
      particles.forEach(pt=>{
        pt.x+=pt.vx;
        pt.y+=pt.vy;
        pt.vy+=0.05;
        pt.life--;
        if (pt.mega) {
          ctx.fillStyle="rgba(255,80,0,0.9)";
          ctx.fillRect(pt.x,pt.y,3,3);
        } else {
          ctx.fillStyle="rgba(255,234,0,0.8)";
          ctx.fillRect(pt.x,pt.y,2,2);
        }
      });
      particles=particles.filter(pt=>pt.life>0);

      // Тълпа отдолу
      if (crowdActive) {
        const baseY = HEIGHT - 6;
        const personWidth = BLOCK * 0.5;
        const personHeight = 6;
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        for (let i=0;i<COLS;i++) {
          const x = i*BLOCK + BLOCK*0.25;
          ctx.fillRect(x, baseY-personHeight, personWidth, personHeight);
        }
        crowdTimer--;
        if (crowdTimer <= 0) crowdActive = false;
      }

      // Game over
      if (gameOver) {
        ctx.fillStyle="rgba(0,0,0,0.8)";
        ctx.fillRect(0,HEIGHT/2-50,WIDTH,100);
        ctx.fillStyle="#ffea00"; ctx.font="24px Arial";
        ctx.textAlign="center";
        ctx.fillText("Оставка!",WIDTH/2,HEIGHT/2-5);
        ctx.fillStyle="#ffffff"; ctx.font="13px Arial";
        ctx.fillText("Натисни „Рестарт“",WIDTH/2,HEIGHT/2+20);
      }

      // TV overlay
      if (spinActive && !gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.75)";
        const barHeight = 24;
        ctx.fillRect(0,0,WIDTH,barHeight);
        ctx.font = "13px Arial";
        ctx.fillStyle = "#ffcc00";
        ctx.textAlign = "center";
        ctx.fillText("TV: Всичко е наред! (забавен кадър)", WIDTH/2, 16);
      }

      // Проверка от ЕС – центриран прозорец
      if (inspectionActive && !gameOver) {
        const boxW = WIDTH * 0.9;
        const boxH = HEIGHT * 0.25;
        const boxX = (WIDTH - boxW) / 2;
        const boxY = (HEIGHT - boxH) / 2;
        ctx.fillStyle = "rgba(0, 0, 0, 0.75)";
        ctx.fillRect(boxX, boxY, boxW, boxH);

        ctx.font = "13px Arial";
        ctx.fillStyle = "#00ffea";
        ctx.textAlign = "center";
        ctx.fillText("Проверка от ЕС: играта е замразена", WIDTH/2, HEIGHT/2 + 4);
      }

      // Пауза
      if (paused && !gameOver) {
        ctx.fillStyle="rgba(0,0,0,0.6)";
        ctx.fillRect(0,HEIGHT/2-35,WIDTH,70);
        ctx.fillStyle="#ffcc00"; ctx.font="18px Arial";
        ctx.textAlign="center";
        ctx.fillText("Пауза",WIDTH/2,HEIGHT/2+5);
      }

      // Хаштаг
      ctx.font="11px Arial"; ctx.textAlign="right";
      ctx.fillStyle="rgba(255,255,255,0.6)";
      ctx.fillText("#Оставка2025",WIDTH-3,HEIGHT-3);

      ctx.restore();
    }

    function stepDown() {
      if (valid(currentPiece,0,1)) {
        currentPiece.y++;
      } else {
        if (currentPiece.type === "pigBomb") {
          triggerPigBombExplosion(currentPiece.x, currentPiece.y);
        } else {
          merge(currentPiece);
        }
        clearLines();
        currentPiece = spawnPiece();
        if (!valid(currentPiece)) gameOver = true;
      }
    }

    function update(t) {
      animationTime = t;
      if (!lastTick) {
        lastTick=t;
        if (spinNextTime === null) {
          spinNextTime = t + 20000;
        }
      }

      if (inspectionActive) {
        inspectionTimer--;
        if (inspectionTimer <= 0) {
          inspectionActive = false;
          score += 100;
          scoreEl.textContent = score;
          popups.push({
            x: 1.5,
            y: 0.5,
            text: "Проверката приключи",
            life: 140,
            center: true
          });
        }
      }

      if (!gameOver && !inspectionActive) {
        if (!spinActive && t >= spinNextTime) {
          spinActive = true;
          spinEndTime = t + 3000;
          spinNextTime = t + 20000;
          updateFallSpeed();
          popups.push({
            x: 1.5,
            y: 0.5,
            text: "TV: Всичко е наред!",
            life: 140,
            center: true
          });
        } else if (spinActive && t >= spinEndTime) {
          spinActive = false;
          updateFallSpeed();
        }
      }

      if (!paused && !gameOver && !inspectionActive && t-lastTick>fallSpeed) {
        stepDown(); 
        lastTick=t;
      }
      draw();
      requestAnimationFrame(update);
    }

    function handleAction(a) {
      if (gameOver || paused || inspectionActive) return;

      if (a === "left" && valid(currentPiece, -1, 0)) currentPiece.x--;
      if (a === "right" && valid(currentPiece, 1, 0)) currentPiece.x++;
      if (a === "down" && valid(currentPiece, 0, 1)) currentPiece.y++;
      if (a === "rotate") {
        const rot = rotateShape(currentPiece.cells);
        if (valid(currentPiece, 0, 0, rot)) currentPiece.cells = rot;
      }
      if (a === "drop") {
        while (valid(currentPiece, 0, 1)) currentPiece.y++;
        stepDown();
      }

      draw();
    }

    document.addEventListener("keydown",e=>{
      if(e.code==="ArrowLeft")handleAction("left");
      if(e.code==="ArrowRight")handleAction("right");
      if(e.code==="ArrowDown")handleAction("down");
      if(e.code==="ArrowUp")handleAction("rotate");
      if(e.code==="Space"){e.preventDefault();handleAction("drop");}
    });

    touchButtons.forEach(b=>{
      b.onclick=()=>handleAction(b.dataset.action);
    });

    pauseBtn.onclick=()=>{
      if (gameOver) return;
      paused=!paused;
      pauseBtn.textContent=paused?"Продължи":"Пауза";
      if(!paused) lastTick=performance.now();
      draw();
    };

    restartBtn.onclick=initGame;

    toggleMusicBtn.onclick=()=>{
      if(!bgm)return;
      if(!musicPlaying){
        try {
          const p = bgm.play();
          if (p && p.then) {
            p.then(()=>{
              musicPlaying=true;
              toggleMusicBtn.textContent="Спри музиката";
            }).catch(()=>{});
          }
        } catch(e){}
      } else {
        bgm.pause();
        musicPlaying=false;
        toggleMusicBtn.textContent="Пусни музика";
      }
    };

    function initGame() {
      board = emptyBoard();
      currentPiece = spawnPiece();
      score = 0;
      gameOver = false;
      paused = false;
      linesClearedTotal = 0;
      level = 1;
      spinActive = false;
      spinNextTime = null;
      spinEndTime = 0;

      rage = 0;
      rageEl.textContent = "0 / " + RAGE_MAX;

      updateFallSpeed();

      scoreEl.textContent = score;
      levelEl.textContent = level;
      pauseBtn.textContent="Пауза";
      lastTick = 0;
      popups = [];
      particles = [];
      animationTime = 0;

      crowdActive = false;
      crowdTimer = 0;
      shakeTimer = 0;

      inspectionActive = false;
      inspectionTimer = 0;
      inspectionStep = 0;

      draw();
    }

    initGame();
    requestAnimationFrame(update);
  </script>
</body>
</html>
