<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Protest Tetris</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: Arial, sans-serif;
      color: #fff;
      background:
        linear-gradient(rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.85)),
        url("sofia.png") center/cover no-repeat fixed;
      background-color: #050813;
    }

    .wrapper {
      display: flex;
      flex-direction: row;
      gap: 12px;
      align-items: flex-start;
      padding: 8px 10px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
      max-width: 100%;
      box-sizing: border-box;
    }

    #game {
      background: transparent;
      border: 2px solid #555;
      display: block;
    }

    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 165px;
    }

    button {
      padding: 5px 7px;
      font-size: 12px;
      border: none;
      cursor: pointer;
      background: #ffcc00;
      color: #000;
      border-radius: 8px;
    }

    button:hover {
      filter: brightness(1.1);
    }

    /* BIG, comfy touch controls */
    .touch-controls {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
      margin-top: 10px;
      width: 100%;
    }

    .touch-controls button {
      padding: 10px;
      font-size: 18px;
      min-height: 52px;
      border-radius: 10px;
      font-weight: bold;
    }

    /* NEW: system controls row under main controls */
    .system-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 10px;
      width: 100%;
      justify-content: space-between;
    }

    .system-controls button {
      flex: 1 1 30%;
      padding: 6px;
      font-size: 11px;
      min-height: 34px;
      border-radius: 8px;
      font-weight: normal;
    }

    .label {
      font-weight: bold;
      font-size: 13px;
    }

    .value {
      font-size: 15px;
      margin-top: 1px;
    }

    @media (max-width: 700px) {
      body {
        justify-content: center;
        align-items: flex-start;
        padding-top: 6px;
      }

      .wrapper {
        flex-direction: column;
        align-items: center;
        width: 100%;
        max-width: 380px;
      }

      .side-panel {
        width: 100%;
        align-items: stretch;
      }

      #game {
        margin-bottom: 6px;
      }
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <canvas id="game"></canvas>

    <div class="side-panel">
      <div>
        <div class="label">Corruption cleared:</div>
        <div id="score" class="value">0</div>
      </div>

      <div>
        <div class="label">Level:</div>
        <div id="level" class="value">1</div>
      </div>

      <div style="font-size:10px;opacity:0.9;max-width:220px;">
        ← → move, ↓ drop, ↑ rotate, Space = hard drop
      </div>

      <!-- MAIN TOUCH CONTROLS (big, for thumbs) -->
      <div class="touch-controls">
        <button data-action="left">◀</button>
        <button data-action="down">⬇</button>
        <button data-action="right">▶</button>
        <button data-action="rotate">⟳</button>
        <button data-action="drop">⤓</button>
        <!-- last grid cell left empty for spacing -->
      </div>

      <!-- SMALLER SYSTEM CONTROLS BELOW -->
      <div class="system-controls">
        <button id="restart">Restart</button>
        <button id="pause">Pause</button>
        <button id="toggleMusic">Play music</button>
      </div>
    </div>
  </div>

  <audio id="bgm" src="music.mp3" loop></audio>
  <audio id="chant" src="chant.mp3"></audio>

  <script>
    // ===== CONFIG =====
    const COLS = 10;
    const ROWS = 20;
    const BLOCK = 22;       // logical block size (small for phones)
    const BASE_SPEED = 500;

    const WIDTH = COLS * BLOCK;
    const HEIGHT = ROWS * BLOCK;

    const boikoImages = [];
    ["boiko.png", "boiko_1.png", "boiko_2.png"].forEach(src => {
      const img = new Image();
      img.src = src;
      boikoImages.push(img);
    });

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    // Hi-DPI scaling for sharper Boiko tiles
    const dpr = window.devicePixelRatio || 1;
    canvas.width = WIDTH * dpr;
    canvas.height = HEIGHT * dpr;
    canvas.style.width = WIDTH + "px";
    canvas.style.height = HEIGHT + "px";
    ctx.scale(dpr, dpr);

    const scoreEl = document.getElementById("score");
    const levelEl = document.getElementById("level");
    const bgm = document.getElementById("bgm");
    const chant = document.getElementById("chant");
    const toggleMusicBtn = document.getElementById("toggleMusic");
    const restartBtn = document.getElementById("restart");
    const pauseBtn = document.getElementById("pause");
    const touchButtons = document.querySelectorAll(".touch-controls button");

    let musicPlaying = false;
    let board;
    let currentPiece;
    let gameOver;
    let score;
    let lastTick;
    let popups = [];
    let particles = [];
    let paused = false;
    let level = 1;
    let linesClearedTotal = 0;
    let fallSpeed = BASE_SPEED;
    let animationTime = 0;

    // Protest Crowd state
    let crowdActive = false;
    let crowdTimer = 0;

    // Media Spin state (slow motion)
    let spinActive = false;
    let spinNextTime = null;
    let spinEndTime = 0;

    const SHAPES = [
      {cells:[[0,0],[-1,0],[1,0],[2,0]]},
      {cells:[[0,0],[0,1],[1,0],[1,1]]},
      {cells:[[0,0],[-1,0],[1,0],[0,1]]},
      {cells:[[0,0],[0,1],[0,2],[1,2]]},
      {cells:[[0,0],[0,1],[0,2],[-1,2]]},
      {cells:[[0,0],[1,0],[0,1],[-1,1]]},
      {cells:[[0,0],[-1,0],[0,1],[1,1]]}
    ];

    function emptyBoard() {
      return Array.from({length: ROWS}, () => Array(COLS).fill(null));
    }

    function rotate([x,y]) { return [y,-x]; }
    function rotateShape(cells) { return cells.map(rotate); }

    function spawnPiece() {
      const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
      const imgIndex = Math.floor(Math.random() * boikoImages.length);
      return {
        x: Math.floor(COLS/2),
        y: 0,
        cells: shape.cells.map(c=>[...c]),
        imgIndex
      };
    }

    function valid(piece, dx=0, dy=0, newCells=null) {
      const cells = newCells || piece.cells;
      for (const [cx,cy] of cells) {
        const x = piece.x + cx + dx;
        const y = piece.y + cy + dy;
        if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
        if (board[y][x]) return false;
      }
      return true;
    }

    function merge(piece) {
      for (const [cx,cy] of piece.cells) {
        board[piece.y+cy][piece.x+cx] = { imgIndex: piece.imgIndex };
      }
    }

    // center=true => horizontally centered text
    function addPopup(text,row,center=false) {
      popups.push({ x:1.5, y:row, text, life:60, center });
    }

    function addParticlesForRow(row) {
      const y = row * BLOCK + BLOCK/2;
      for (let i=0; i<40; i++) {
        const x = Math.random() * WIDTH;
        const ang = Math.random()*Math.PI*2;
        const sp = 1 + Math.random()*2;
        particles.push({
          x,y,
          vx: Math.cos(ang)*sp,
          vy: Math.sin(ang)*sp - 1,
          life: 40 + Math.random()*20,
          mega: false
        });
      }
    }

    // Protest Crowd power-up: clears one extra random non-empty row
    function triggerCrowdPower() {
      const rowsWithBlocks = [];
      for (let r=0; r<ROWS; r++) {
        if (board[r].some(cell => cell !== null)) {
          rowsWithBlocks.push(r);
        }
      }
      if (rowsWithBlocks.length === 0) return;

      const r = rowsWithBlocks[Math.floor(Math.random() * rowsWithBlocks.length)];
      board.splice(r, 1);
      board.unshift(new Array(COLS).fill(null));

      score += 50;
      scoreEl.textContent = score;

      addPopup("Crowd power!", r, true);
      addParticlesForRow(r);

      crowdActive = true;
      crowdTimer = 120; // frames
    }

    // Mega explosion for every 5th total cleared line
    function addMegaExplosion() {
      for (let i=0; i<250; i++) {
        const x = Math.random() * WIDTH;
        const y = Math.random() * HEIGHT;
        const ang = Math.random()*Math.PI*2;
        const sp = 2 + Math.random()*3;
        particles.push({
          x,y,
          vx: Math.cos(ang)*sp,
          vy: Math.sin(ang)*sp - 1.5,
          life: 60 + Math.random()*40,
          mega: true
        });
      }
      popups.push({
        x: 1.5,
        y: 0.5,
        text: "MEGA BOOM!",
        life: 80,
        center: true
      });
    }

    function updateFallSpeed() {
      const normal = Math.max(150, BASE_SPEED - (level-1)*50);
      // If TV spin is active, go into slow motion (larger interval)
      fallSpeed = spinActive ? normal * 2 : normal;
    }

    // Level up rewards: bonus score + guaranteed crowd power
    function levelUpIfNeeded() {
      const newLevel = Math.floor(linesClearedTotal / 5) + 1;
      if (newLevel !== level) {
        level = newLevel;
        levelEl.textContent = level;

        score += 200;
        scoreEl.textContent = score;
        triggerCrowdPower();

        updateFallSpeed();
        popups.push({
          x: 2,
          y: 1,
          text: "LEVEL " + level,
          life: 80,
          center: true
        });
      }
    }

    function clearLines() {
      let clearedNow = 0;
      for (let r=ROWS-1; r>=0; r--) {
        if (board[r].every(c=>c!==null)) {
          board.splice(r,1);
          board.unshift(new Array(COLS).fill(null));
          score += 100;
          scoreEl.textContent = score;
          linesClearedTotal++;
          clearedNow++;

          addPopup("CORRUPTION -1", r, true);
          addParticlesForRow(r);

          if (linesClearedTotal % 5 === 0) {
            addMegaExplosion();
          }

          r++;
        }
      }

      if (clearedNow >= 1) {
        // 70% chance to trigger crowd power
        if (Math.random() < 0.7) {
          triggerCrowdPower();
        }
      }

      if (clearedNow >= 2 && chant) {
        try {
          chant.currentTime = 0;
          chant.play();
        } catch(e){}
      }
      if (clearedNow > 0) {
        levelUpIfNeeded();
      }
    }

    function drawFlagBackground() {
      const h = HEIGHT/3;
      ctx.fillStyle="#ffffff"; ctx.fillRect(0,0,WIDTH,h);
      ctx.fillStyle="#00966E"; ctx.fillRect(0,h,WIDTH,h);
      ctx.fillStyle="#d62612"; ctx.fillRect(0,2*h,WIDTH,h);
    }

    function drawStaticCell(x,y,cell) {
      const px=x*BLOCK, py=y*BLOCK;
      const img=boikoImages[cell.imgIndex];
      ctx.save();
      if (img && img.complete && img.naturalWidth>0) {
        ctx.drawImage(img,px,py,BLOCK,BLOCK);
      }
      ctx.strokeStyle="rgba(0,0,0,0.7)";
      ctx.lineWidth=1;
      ctx.strokeRect(px+0.5, py+0.5, BLOCK-1, BLOCK-1);
      ctx.restore();
    }

    function drawRotatingCell(x,y,imgIndex) {
      const px=x*BLOCK, py=y*BLOCK;
      const img=boikoImages[imgIndex];
      const t = animationTime || 0;
      const angle = Math.sin(t/350 + (x+y)) * 0.18;

      ctx.save();
      ctx.translate(px + BLOCK/2, py + BLOCK/2);
      ctx.rotate(angle);

      if (img && img.complete && img.naturalWidth>0) {
        ctx.drawImage(img, -BLOCK/2, -BLOCK/2, BLOCK, BLOCK);
      } else {
        ctx.fillStyle="#ffffff";
        ctx.fillRect(-BLOCK/2, -BLOCK/2, BLOCK-1, BLOCK-1);
      }

      ctx.strokeStyle="rgba(0,0,0,0.7)";
      ctx.lineWidth=1;
      ctx.strokeRect(-BLOCK/2+0.5, -BLOCK/2+0.5, BLOCK-1, BLOCK-1);

      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0,0,WIDTH,HEIGHT);
      drawFlagBackground();

      for (let r=0;r<ROWS;r++)
        for (let c=0;c<COLS;c++)
          if (board[r][c]) drawStaticCell(c,r,board[r][c]);

      if (!gameOver && currentPiece) {
        for (const [cx,cy] of currentPiece.cells) {
          drawRotatingCell(currentPiece.x+cx,currentPiece.y+cy,currentPiece.imgIndex);
        }
      }

      // Popups
      popups.forEach(p=>{
        ctx.save();
        ctx.font="13px Arial"; 
        ctx.lineWidth=3;

        let x = p.center ? WIDTH/2 : p.x*BLOCK;
        let y = p.y*BLOCK + BLOCK/2;

        ctx.textAlign = p.center ? "center" : "left";

        ctx.strokeStyle="#000";
        ctx.strokeText(p.text,x,y);
        ctx.fillStyle="#ffea00";
        ctx.fillText(p.text,x,y);

        p.y -= 0.03; 
        p.life--;
        ctx.restore();
      });
      popups=popups.filter(p=>p.life>0);

      // Particles
      particles.forEach(pt=>{
        pt.x+=pt.vx;
        pt.y+=pt.vy;
        pt.vy+=0.05;
        pt.life--;
        if (pt.mega) {
          ctx.fillStyle="rgba(255,80,0,0.9)";
          ctx.fillRect(pt.x,pt.y,3,3);
        } else {
          ctx.fillStyle="rgba(255,234,0,0.8)";
          ctx.fillRect(pt.x,pt.y,2,2);
        }
      });
      particles=particles.filter(pt=>pt.life>0);

      // Protest Crowd silhouettes at bottom
      if (crowdActive) {
        const baseY = HEIGHT - 6;
        const personWidth = BLOCK * 0.5;
        const personHeight = 6;
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        for (let i=0;i<COLS;i++) {
          const x = i*BLOCK + BLOCK*0.25;
          ctx.fillRect(x, baseY-personHeight, personWidth, personHeight);
        }
        crowdTimer--;
        if (crowdTimer <= 0) crowdActive = false;
      }

      // Game over overlay
      if (gameOver) {
        ctx.fillStyle="rgba(0,0,0,0.8)";
        ctx.fillRect(0,HEIGHT/2-50,WIDTH,100);
        ctx.fillStyle="#ffea00"; ctx.font="24px Arial";
        ctx.textAlign="center";
        ctx.fillText("Оставка!",WIDTH/2,HEIGHT/2-5);
        ctx.fillStyle="#ffffff"; ctx.font="13px Arial";
        ctx.fillText("Натисни Restart",WIDTH/2,HEIGHT/2+20);
      }

      // Media Spin overlay (slow motion)
      if (spinActive && !gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.75)";
        const barHeight = 24;
        ctx.fillRect(0,0,WIDTH,barHeight);
        ctx.font = "13px Arial";
        ctx.fillStyle = "#ffcc00";
        ctx.textAlign = "center";
        ctx.fillText("TV: Всичко е наред! (slow motion)", WIDTH/2, 16);
      }

      // Pause overlay
      if (paused && !gameOver) {
        ctx.fillStyle="rgba(0,0,0,0.6)";
        ctx.fillRect(0,HEIGHT/2-35,WIDTH,70);
        ctx.fillStyle="#ffcc00"; ctx.font="18px Arial";
        ctx.textAlign="center";
        ctx.fillText("Пауза",WIDTH/2,HEIGHT/2+5);
      }

      // Watermark
      ctx.font="11px Arial"; ctx.textAlign="right";
      ctx.fillStyle="rgba(255,255,255,0.6)";
      ctx.fillText("#Оставка2025",WIDTH-3,HEIGHT-3);
    }

    function stepDown() {
      if (valid(currentPiece,0,1)) currentPiece.y++;
      else {
        merge(currentPiece);
        clearLines();
        currentPiece=spawnPiece();
        if (!valid(currentPiece)) gameOver=true;
      }
    }

    function update(t) {
      animationTime = t;
      if (!lastTick) {
        lastTick=t;
        if (spinNextTime === null) {
          spinNextTime = t + 20000;  // first TV spin after 20s
        }
      }

      // Media Spin timing (slow motion)
      if (!gameOver) {
        if (!spinActive && t >= spinNextTime) {
          spinActive = true;
          spinEndTime = t + 3000;      // 3s duration
          spinNextTime = t + 20000;    // next spin in 20s
          updateFallSpeed();
          popups.push({
            x: 1.5,
            y: 0.5,
            text: "TV: Всичко е наред!",
            life: 80,
            center: true
          });
        } else if (spinActive && t >= spinEndTime) {
          spinActive = false;
          updateFallSpeed();
        }
      }

      if (!paused && !gameOver && t-lastTick>fallSpeed) {
        stepDown(); 
        lastTick=t;
      }
      draw();
      requestAnimationFrame(update);
    }

    function handleAction(a) {
      if (gameOver || paused) return;

      if (a === "left" && valid(currentPiece, -1, 0)) currentPiece.x--;
      if (a === "right" && valid(currentPiece, 1, 0)) currentPiece.x++;
      if (a === "down" && valid(currentPiece, 0, 1)) currentPiece.y++;
      if (a === "rotate") {
        const rot = rotateShape(currentPiece.cells);
        if (valid(currentPiece, 0, 0, rot)) currentPiece.cells = rot;
      }
      if (a === "drop") {
        while (valid(currentPiece, 0, 1)) currentPiece.y++;
        stepDown();
      }

      draw();
    }

    document.addEventListener("keydown",e=>{
      if(e.code==="ArrowLeft")handleAction("left");
      if(e.code==="ArrowRight")handleAction("right");
      if(e.code==="ArrowDown")handleAction("down");
      if(e.code==="ArrowUp")handleAction("rotate");
      if(e.code==="Space"){e.preventDefault();handleAction("drop");}
    });

    touchButtons.forEach(b=>{
      b.onclick=()=>handleAction(b.dataset.action);
    });

    pauseBtn.onclick=()=>{
      if (gameOver) return;
      paused=!paused;
      pauseBtn.textContent=paused?"Resume":"Pause";
      if(!paused) lastTick=performance.now();
      draw();
    };

    restartBtn.onclick=initGame;

    toggleMusicBtn.onclick=()=>{
      if(!bgm)return;
      if(!musicPlaying){
        try {
          const p = bgm.play();
          if (p && p.then) {
            p.then(()=>{
              musicPlaying=true;
              toggleMusicBtn.textContent="Pause music";
            }).catch(()=>{});
          }
        } catch(e){}
      } else {
        bgm.pause();
        musicPlaying=false;
        toggleMusicBtn.textContent="Play music";
      }
    };

    function initGame() {
      board = emptyBoard();
      currentPiece = spawnPiece();
      score = 0;
      gameOver = false;
      paused = false;
      linesClearedTotal = 0;
      level = 1;
      spinActive = false;
      spinNextTime = null;
      spinEndTime = 0;

      updateFallSpeed();

      scoreEl.textContent = score;
      levelEl.textContent = level;
      pauseBtn.textContent="Pause";
      lastTick = 0;
      popups = [];
      particles = [];
      animationTime = 0;

      crowdActive = false;
      crowdTimer = 0;

      draw();
    }

    initGame();
    requestAnimationFrame(update);
  </script>
</body>
</html>
