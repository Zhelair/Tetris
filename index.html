<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Protest Tetris</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: Arial, sans-serif;
      color: #fff;
      background:
        linear-gradient(rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.85)),
        url("sofia.png") center/cover no-repeat fixed;
      background-color: #050813;
    }

    .wrapper {
      display: flex;
      flex-direction: row;
      gap: 16px;
      align-items: flex-start;
      padding: 10px 12px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
      max-width: 100%;
    }

    #game {
      background: transparent;
      border: 2px solid #555;
      max-width: 100%;
    }

    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-width: 200px;
    }

    button {
      padding: 8px 10px;
      font-size: 14px;
      border: none;
      cursor: pointer;
      background: #ffcc00;
      color: #000;
      border-radius: 8px;
    }

    button:hover {
      filter: brightness(1.1);
    }

    .touch-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .touch-controls button {
      flex: 1 1 30%;
      padding: 10px;
      font-size: 18px;
      border-radius: 8px;
    }

    @media (max-width: 700px) {
      .wrapper {
        flex-direction: column;
        align-items: center;
      }
      .side-panel {
        width: 100%;
        align-items: stretch;
      }
      #game {
        width: 100%;
        height: auto;
      }
    }

    .label {
      font-weight: bold;
      font-size: 15px;
    }

    .value {
      font-size: 18px;
      margin-top: 2px;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <canvas id="game"></canvas>

    <div class="side-panel">
      <div>
        <div class="label">Corruption cleared:</div>
        <div id="score" class="value">0</div>
      </div>

      <div>
        <div class="label">Level:</div>
        <div id="level" class="value">1</div>
      </div>

      <button id="restart">Restart</button>
      <button id="pause">Pause</button>
      <button id="toggleMusic">Play music</button>

      <div style="font-size:12px;opacity:0.9;max-width:190px;">
        ← → move, ↓ drop, ↑ rotate, Space = hard drop
      </div>

      <div class="touch-controls">
        <button data-action="left">◀</button>
        <button data-action="down">⬇</button>
        <button data-action="right">▶</button>
        <button data-action="rotate">⟳</button>
        <button data-action="drop">⤓</button>
      </div>
    </div>
  </div>

  <!-- Music (optional) -->
  <audio id="bgm" src="music.mp3" loop></audio>
  <!-- Protest chant (optional, plays on multi-line clear) -->
  <audio id="chant" src="chant.mp3"></audio>

  <script>
    // ===== CONFIG =====
    const COLS = 10;
    const ROWS = 20;
    const BLOCK = 32;     // good size for phone + desktop
    const BASE_SPEED = 500; // base fall speed in ms

    // Multiple Boiko images
    const boikoImages = [];
    ["boiko.png", "boiko_1.png", "boiko_2.png"].forEach(src => {
      const img = new Image();
      img.src = src;
      boikoImages.push(img);
    });

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    canvas.width = COLS * BLOCK;
    canvas.height = ROWS * BLOCK;

    const scoreEl = document.getElementById("score");
    const levelEl = document.getElementById("level");
    const bgm = document.getElementById("bgm");
    const chant = document.getElementById("chant");
    const toggleMusicBtn = document.getElementById("toggleMusic");
    const restartBtn = document.getElementById("restart");
    const pauseBtn = document.getElementById("pause");
    const touchButtons = document.querySelectorAll(".touch-controls button");

    let musicPlaying = false;

    // ===== GAME STATE =====
    let board;
    let currentPiece;
    let gameOver;
    let score;
    let lastTick;
    let popups = [];     // "CORRUPTION -1"
    let particles = [];  // explosion particles
    let paused = false;
    let level = 1;
    let linesClearedTotal = 0;
    let fallSpeed = BASE_SPEED;

    // ===== SHAPES =====
    const SHAPES = [
      { cells:[[0,0],[-1,0],[1,0],[2,0]] },     // I
      { cells:[[0,0],[0,1],[1,0],[1,1]] },      // O
      { cells:[[0,0],[-1,0],[1,0],[0,1]] },     // T
      { cells:[[0,0],[0,1],[0,2],[1,2]] },      // L
      { cells:[[0,0],[0,1],[0,2],[-1,2]] },     // J
      { cells:[[0,0],[1,0],[0,1],[-1,1]] },     // S
      { cells:[[0,0],[-1,0],[0,1],[1,1]] }      // Z
    ];

    // ===== HELPERS =====
    function emptyBoard() {
      return Array.from({length: ROWS}, () => Array(COLS).fill(null));
    }

    function rotate([x,y]) { return [y,-x]; }
    function rotateShape(cells) { return cells.map(rotate); }

    function spawnPiece() {
      const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
      const imgIndex = Math.floor(Math.random() * boikoImages.length);
      return {
        x: Math.floor(COLS/2),
        y: 0,
        cells: shape.cells.map(c=>[...c]),
        imgIndex
      };
    }

    function valid(piece, dx=0, dy=0, newCells=null) {
      const cells = newCells || piece.cells;
      for (const [cx,cy] of cells) {
        const x = piece.x + cx + dx;
        const y = piece.y + cy + dy;
        if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
        if (board[y][x]) return false;
      }
      return true;
    }

    function merge(piece) {
      for (const [cx,cy] of piece.cells) {
        board[piece.y+cy][piece.x+cx] = { imgIndex: piece.imgIndex };
      }
    }

    function addPopup(text,row) {
      popups.push({ x:1.5, y:row, text, life:60 });
    }

    // Particle explosion when lines cleared
    function addParticlesForRow(row) {
      const y = row * BLOCK + BLOCK/2;
      for (let i=0; i<40; i++) {
        const x = Math.random() * canvas.width;
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random()*2;
        particles.push({
          x,
          y,
          vx: Math.cos(angle)*speed,
          vy: Math.sin(angle)*speed - 1,
          life: 40 + Math.random()*20
        });
      }
    }

    function levelUpIfNeeded() {
      const newLevel = Math.floor(linesClearedTotal / 5) + 1; // +1 so start at level 1
      if (newLevel !== level) {
        level = newLevel;
        levelEl.textContent = level;
        // Increase speed, but not too crazy
        fallSpeed = Math.max(150, BASE_SPEED - (level-1)*50);
        // Optional popup
        popups.push({
          x: 2,
          y: 1,
          text: "LEVEL " + level,
          life: 80
        });
      }
    }

    function clearLines() {
      let clearedNow = 0;
      for (let r=ROWS-1; r>=0; r--) {
        if (board[r].every(c=>c!==null)) {
          board.splice(r,1);
          board.unshift(new Array(COLS).fill(null));
          score += 100;
          scoreEl.textContent = score;
          linesClearedTotal++;
          clearedNow++;

          addPopup("CORRUPTION -1", r);
          addParticlesForRow(r);

          r++; // re-check
        }
      }

      if (clearedNow >= 2 && chant) {
        try {
          chant.currentTime = 0;
          chant.play();
        } catch(e) {}
      }

      if (clearedNow > 0) {
        levelUpIfNeeded();
      }
    }

    // ===== DRAWING =====
    function drawFlagBackground() {
      const stripeHeight = canvas.height/3;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0,0,canvas.width,stripeHeight);

      ctx.fillStyle = "#00966E";
      ctx.fillRect(0,stripeHeight,canvas.width,stripeHeight);

      ctx.fillStyle = "#d62612";
      ctx.fillRect(0,2*stripeHeight,canvas.width,stripeHeight);
    }

    function drawCell(x,y,cell) {
      const px = x*BLOCK, py = y*BLOCK;
      const img = boikoImages[cell.imgIndex];
      if (img && img.complete && img.naturalWidth > 0) {
        ctx.drawImage(img, px, py, BLOCK, BLOCK);
      }
    }

    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawFlagBackground();

      // board
      for (let r=0;r<ROWS;r++)
        for (let c=0;c<COLS;c++)
          if (board[r][c]) drawCell(c,r,board[r][c]);

      // active piece
      if (currentPiece && !gameOver) {
        for (const [cx,cy] of currentPiece.cells)
          drawCell(currentPiece.x+cx,currentPiece.y+cy,{imgIndex:currentPiece.imgIndex});
      }

      // popups
      popups.forEach(p=>{
        ctx.font="16px Arial";
        ctx.lineWidth=3;
        let sx=p.x*BLOCK;
        let sy=p.y*BLOCK+BLOCK/2;
        ctx.strokeStyle="#000";
        ctx.strokeText(p.text,sx,sy);
        ctx.fillStyle="#ffea00";
        ctx.fillText(p.text,sx,sy);
        p.y -= 0.03;
        p.life--;
      });
      popups = popups.filter(p=>p.life>0);

      // particles
      particles.forEach(pr=>{
        pr.x += pr.vx;
        pr.y += pr.vy;
        pr.vy += 0.05; // gravity
        pr.life--;
        ctx.fillStyle = "rgba(255, 234, 0, 0.8)";
        ctx.fillRect(pr.x, pr.y, 2, 2);
      });
      particles = particles.filter(pr=>pr.life>0);

      // game over overlay
      if (gameOver) {
        ctx.fillStyle="rgba(0,0,0,0.8)";
        ctx.fillRect(0,canvas.height/2-60,canvas.width,120);

        ctx.fillStyle="#ffea00";
        ctx.font="32px Arial";
        ctx.textAlign="center";
        ctx.fillText("Оставка!", canvas.width/2, canvas.height/2-5);

        ctx.fillStyle="#ffffff";
        ctx.font="16px Arial";
        ctx.fillText("Натисни Restart, за да опиташ отново.", canvas.width/2, canvas.height/2+25);
      }

      // pause overlay
      if (paused && !gameOver) {
        ctx.fillStyle="rgba(0,0,0,0.6)";
        ctx.fillRect(0,canvas.height/2-40,canvas.width,80);
        ctx.fillStyle="#ffcc00";
        ctx.font="24px Arial";
        ctx.textAlign="center";
        ctx.fillText("Пауза", canvas.width/2, canvas.height/2+5);
      }

      // watermark
      ctx.font = "14px Arial";
      ctx.textAlign = "right";
      ctx.fillStyle = "rgba(255,255,255,0.6)";
      ctx.fillText("#Оставка2025", canvas.width - 6, canvas.height - 6);
    }

    // ===== GAME LOOP =====
    function stepDown() {
      if (valid(currentPiece,0,1)) currentPiece.y++;
      else {
        merge(currentPiece);
        clearLines();
        currentPiece = spawnPiece();
        if (!valid(currentPiece)) gameOver=true;
      }
    }

    function update(t) {
      if (!lastTick) lastTick = t;

      if (!paused && !gameOver && t-lastTick > fallSpeed) {
        stepDown();
        lastTick = t;
      }

      draw();
      requestAnimationFrame(update);
    }

    // ===== INPUT / CONTROLS =====
    function handleAction(a) {
      if (gameOver || paused) return;
      if (a==="left" && valid(currentPiece,-1,0)) currentPiece.x--;
      if (a==="right" && valid(currentPiece,1,0)) currentPiece.x++;
      if (a==="down" && valid(currentPiece,0,1)) currentPiece.y++;
      if (a==="rotate") {
        const rot = rotateShape(currentPiece.cells);
        if (valid(currentPiece,0,0,rot)) currentPiece.cells=rot;
      }
      if (a==="drop") {
        while (valid(currentPiece,0,1)) currentPiece.y++;
        stepDown();
      }
      draw();

      // auto-start music on first action
      if (!musicPlaying && bgm && bgm.paused) {
        bgm.play().then(()=>{
          musicPlaying=true;
          toggleMusicBtn.textContent="Pause music";
        }).catch(()=>{});
      }
    }

    document.addEventListener("keydown",(e)=>{
      if(e.code==="ArrowLeft")handleAction("left");
      if(e.code==="ArrowRight")handleAction("right");
      if(e.code==="ArrowDown")handleAction("down");
      if(e.code==="ArrowUp")handleAction("rotate");
      if(e.code==="Space"){e.preventDefault();handleAction("drop");}
    });

    touchButtons.forEach(b=>{
      b.onclick=()=>handleAction(b.dataset.action);
    });

    pauseBtn.onclick=function(){
      if(gameOver)return;
      paused=!paused;
      pauseBtn.textContent=paused?"Resume":"Pause";
      if(!paused) lastTick=performance.now();
      draw();
    };

    restartBtn.onclick=initGame;

    toggleMusicBtn.onclick=function(){
      if(!bgm)return;
      if(!musicPlaying){
        bgm.play().then(()=>{
          musicPlaying=true;
          toggleMusicBtn.textContent="Pause music";
        }).catch(()=>{});
      } else {
        bgm.pause();
        musicPlaying=false;
        toggleMusicBtn.textContent="Play music";
      }
    };

    // ===== INIT =====
    function initGame() {
      board = emptyBoard();
      currentPiece = spawnPiece();
      score = 0;
      gameOver = false;
      paused = false;
      linesClearedTotal = 0;
      level = 1;
      fallSpeed = BASE_SPEED;
      scoreEl.textContent = score;
      levelEl.textContent = level;
      pauseBtn.textContent="Pause";
      lastTick=0;
      popups=[];
      particles=[];
      draw();
    }

    initGame();
    requestAnimationFrame(update);
  </script>
</body>
</html>
